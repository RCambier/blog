<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Python multiprocessing with loading bar</h1><p class="page-description">Create a nice multiprocessing logic with a loading bar</p>

    
      
        <div class="pb-5 d-flex flex-wrap flex-justify-end">
          <div class="px-2">

    <a href="https://github.com/RCambier/blog/tree/master/_notebooks/2022-04-01-multiprocessing.ipynb" role="button" target="_blank">
<img class="notebook-badge-image" src="/blog/assets/badges/github.svg" alt="View On GitHub">
    </a>
</div>

          <div class="px-2">
    <a href="https://mybinder.org/v2/gh/RCambier/blog/master?filepath=_notebooks%2F2022-04-01-multiprocessing.ipynb" target="_blank">
        <img class="notebook-badge-image" src="/blog/assets/badges/binder.svg" alt="Open In Binder"/>
    </a>
</div>

          <div class="px-2">
    <a href="https://colab.research.google.com/github/RCambier/blog/blob/master/_notebooks/2022-04-01-multiprocessing.ipynb" target="_blank">
        <img class="notebook-badge-image" src="/blog/assets/badges/colab.svg" alt="Open In Colab"/>
    </a>
</div>
        </div>
      </header>

  <div class="post-content e-content" itemprop="articleBody">
    <!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2022-04-01-multiprocessing.ipynb
-->

<div class="container" id="notebook-container">
        
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Multiprocessing in Python is already not the best. But on top of it, I always want to add a loading bar that tells me how much work has been performed. 
It took me a while to figure out how to best do that.</p>
<p>What I want is:</p>
<ul>
<li>Work gets done in parrallel, either in threads or in processes depending on how much GIL locking there is in my function. </li>
<li>The loading bar progresses as work gets done. </li>
<li>When the progress bars hits the end, work is finished.</li>
<li>You can pipe a generator into the parrallel processing, and it will be consumed progressively</li>
</ul>
<p>What I settled for is the below code. It consumes the <code>iterable</code> generator progressively, and displays a progress bar indicating how much work has been achieved.</p>
<h3 id="For-multiprocessing:">For multiprocessing:<a class="anchor-link" href="#For-multiprocessing:"> </a></h3>
</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-python"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing.pool</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">from</span> <span class="nn">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span> 
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">work_function</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span> 
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">arg</span>

<span class="k">def</span> <span class="nf">iterable</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">):</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">i</span>

<span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">as</span> <span class="n">p</span><span class="p">:</span> 
    <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">work_function</span><span class="p">,</span> <span class="n">iterable</span><span class="p">(),</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;done&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="For-multithreading:">For multithreading:<a class="anchor-link" href="#For-multithreading:"> </a></h3>
</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-python"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing.pool</span> <span class="kn">import</span> <span class="n">ThreadPool</span>
<span class="kn">from</span> <span class="nn">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span> 
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">work_function</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span> 
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">arg</span>

<span class="k">def</span> <span class="nf">iterable</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">):</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">i</span>

<span class="k">with</span> <span class="n">ThreadPool</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">as</span> <span class="n">p</span><span class="p">:</span> 
    <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">work_function</span><span class="p">,</span> <span class="n">iterable</span><span class="p">(),</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;done&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Why-not-use-concurrent.futures-?">Why not use concurrent.futures ?<a class="anchor-link" href="#Why-not-use-concurrent.futures-?"> </a></h2><p>Because this option does not allow for the <code>imap</code> multiprocessing. This means that all the iterable will be consumed before being sent to the workers. This could be fine, but sometimes, if the iterable takes time to compute or is a generator itself, you don't want to consume it fully before starting the concurrent processing.</p>
<p>Try the code below. Notice that the loading bar starts appearing once the iterable has been consumed, which means it already reached the 13/20 iteration.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-python"><pre><span></span><span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ProcessPoolExecutor</span>
<span class="kn">from</span> <span class="nn">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span> 
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">work_function</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span> 
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">arg</span>

<span class="k">def</span> <span class="nf">iterable</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">):</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">i</span>

<span class="k">with</span> <span class="n">ProcessPoolExecutor</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">as</span> <span class="n">p</span><span class="p">:</span> 
    <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">work_function</span><span class="p">,</span> <span class="n">iterable</span><span class="p">(),</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;done&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="What-about-tqdm-process_map-?">What about tqdm process_map ?<a class="anchor-link" href="#What-about-tqdm-process_map-?"> </a></h1><p><code>tqdm.contrib.concurrent.process_map</code> is essentially the same as the concurrent.futures behind the scenes, and will exhibit the same behavior.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="How-to-share-data-accross-workers">How to share data accross workers<a class="anchor-link" href="#How-to-share-data-accross-workers"> </a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>When you use thread workers, the data will simply be accessible to every thread directly. You can share it as a variable or as a global object.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-python"><pre><span></span><span class="n">some_global_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="s2">&quot;huge_file.parquet&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">work_function</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span> 
    <span class="c1"># `some_global_data` and `arg` are coming straight form the memory</span>
    <span class="c1"># shared accross threads</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">some_global_data</span><span class="p">[</span><span class="n">some_global_data</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">some_data</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">s</span>

<span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">as</span> <span class="n">p</span><span class="p">:</span> 
    <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">work_function</span><span class="p">,</span> <span class="n">iterable</span><span class="p">())))</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>However, when you use process workers, the data shared to workers as arguments is most often pickled and shared as a string. This could quickly be an issue. For 2 reasons:</p>
<ul>
<li>Pickling a big object and sending it to every worker can be very expensive</li>
<li>This will copy the object many times, which could harm the available memory</li>
</ul>
<p>The global data is shared directly from the memory, but it is copied to each worker. Which is also harming the memory.</p>
<p>So what can we do ? Not a lot, there are no great mechanics (that I am aware of) to share data accross process workers in Python. It's basically a work in progress: <a href="https://lukasz.langa.pl/5d044f91-49c1-4170-aed1-62b6763e6ad0/">https://lukasz.langa.pl/5d044f91-49c1-4170-aed1-62b6763e6ad0/</a></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>There is still a trick you can use, but with varying degrees of success. It's to simply share the object globally accross the workers.</p>
<p>When Python starts a process, it's going to fork the main process. This means that all data will be copied to the child processes. But it's going to do a <em>copy on write</em>. This means that the underlying data will still be read from the main process (even from a child process) and will only be copied when it changes. This means that you can share the data accross all the processes withtout any memory increases.</p>
<p>Unfortunately, this assumption does not hold very long in Python. Since Python modifies object for reference counting (and other) reasons behind the scenes, the object will soon be copied to the child process even if you don't explicity modify it yourself.</p>
<p>Still, I've noticed that this often works and saves me when processing a huge object with many processes. I would then do something like this:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-python"><pre><span></span><span class="n">big_object</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="s2">&quot;big_file.parquet&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">work_function</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span> 
    <span class="c1"># big object is in the global scope, and might not be copied to the</span>
    <span class="c1"># child process for a while. </span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">big_object</span><span class="p">[</span><span class="n">big_object</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">arg</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">s</span>

<span class="k">with</span> <span class="n">ProcessPoolExecutor</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">as</span> <span class="n">p</span><span class="p">:</span> 
    <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">work_function</span><span class="p">,</span> <span class="n">iterable</span><span class="p">())))</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

</div>



  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="RCambier/blog"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/blog/programming/2022/04/01/multiprocessing.html" hidden></a>
</article>